## Какво е „чиста функция“
Чиста функция:
- винаги връща **един и същ резултат** при едни и същи аргументи;
- **няма странични ефекти** (не чете/пише в конзола/файлове, не променя външно състояние);
- зависимостите ѝ са изцяло през аргументите.

> В Haskell входно-изходните действия са отделени в типа `IO a`, което изолира ефектите от чистите изчисления.

### Зад. 1 Функция, която увеличава стойността на параметъра с 1

	add :: Int -> Int 
	add x = x + 1	

-- Пример: add 5 == 6
---------------------------------------------------------------------

### Зад. 2  Функция, която връща произведение на два параметъра (Double)

	multy :: Double -> Double -> Double
	multy a b = a * b

-- Пример: multy 2.5 4.0 == 10.0
----------------------------------------------------------------------

### Зад. 3 Функцията от задача 2 с обобщена (полиморфна) версия за числови типове

	multyNum :: Num a => a -> a -> a
	multyNum x y = x * y

-- Пример: multyNum (2 :: Int) (3 :: Int) == 6
--         multyNum (2.5 :: Double) 4.0   == 10.0
----------------------------------------------------------------------

### Зад. 4 - Сума на първите n естествени числа
	
	sumN :: Int -> Int
	sumN n = sum [1 .. n] -Използва стандартната функция `sum` и генерира списък [1..n]

-- Пример: sumN 5 == 15
----------------------------------------------------------------------

### Зад. 5 - Умножава по-голямото от две стойности с трета (множествени ограничения)

	multyMax :: (Num a, Ord a) => a -> a -> a -> a
	multyMax a b x = (max a b) * x     --  (**max** - вградена функция в Haskell)

-- Пример: multyMax 2 5 10 == 50
----------------------------------------------------------------------

### Зад. 6 - Максимум по естествен ред  ( същата функция като max )

	max1 :: Ord a => a -> a -> a
	max1 x y =
 	     if x >= y
   		 then x
   		 else y

-- Пример: max1 "echo" "eho" == "eho" (лексикографски ред)
--         multyNum (2.5 :: Double) 4.0 == 10.0
-----------------------------------------------------------------------

### Зад. 7- Максимум по дължина (за низове)

	maxLen :: String -> String -> String
	maxLen a b =
  		if length a >= length b
   			then a
    			else b

-- Пример: maxLen "cat" "tiger" == "tiger"
----------------------------------------------------------------------

### Зад. 8 - Приема функция (First-class Function) и я изпълнява с параметър 3

	pass3 :: Num t1 => (t1 -> t2) -> t2   
	pass3 f = f 3

-- Пример: pass3 add == 4 (add е дефинирана по-горе)
----------------------------------------------------------------------

### Зад. 9 - Умножение по 2 (общ числов тип)

	mult2 :: Num a => a -> a
	mult2 x = 2 * x

-- Пример: mult2 7 == 14
----------------------------------------------------------------------

### Зад. 10 - Композиция на функции

	- резултатът на втората функция е аргумент на първата
	compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2 
	compose f g x = f (g x)

-- Пример: (compose add mult2) 3 == add (mult2 3) == 7
----------------------------------------------------------------------


## Забележки
- Типовите ограничения (`Num a`, `Ord a` и т.н.) описват **какви операции са допустими** върху абстрактния тип `a`.
- Композицията на функции позволява да изграждате нови функции от наличните без да въвеждате състояние или ефекти.
- Всички горни функции са **детерминистични** и **без странични ефекти** — т.е. *чисти*.
