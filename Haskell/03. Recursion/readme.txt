# Рекурсия
Рекурсия е начин за решаване на задачи, при който една функция извиква сама себе си.
Това продължава, докато се стигне до базов случай – най-простият вариант на задачата, 
който може да се реши директно, без ново извикване.

Във функционалните езици за програмиране рекурсията се използва вместо циклични оператори. 
Тя позволява програмата да се описва по декларативен начин, без използване на променливи,
които изменят състоянието си.

# Всяка рекурсивна дефиниция в Haskell трябва да съдържа ясно разграничени два компонента:
- базов случай - определя условието, при което рекурсивният процес спира.
- рекурсивен случай - описва редукцията на изчислителния проблем до по-малък подпроблем
  от същия тип и прилага функцията върху него.

## Опашкова рекурсия (Tail Recursion) 
Специален вид рекурсия, при която рекурсивното извикване е последната операция във функцията
(след рекурсивното извикване няма други оператори (напр. +, *, ++) ).

В обикновената рекурсия програмата трябва да запомня междинни стъпки (например да изчака
резултата от рекурсивния повик, за да извърши още едно умножение или събиране).
При опашковата рекурсия това не е нужно — функцията предава резултата напред чрез параметър
и не задържа никакви операции след рекурсивното извикване.

## Предимство:
При опашкова рекурсия не се натрупват извиквания в стека,
защото всяко рекурсивно извикване може да замести предходното.
-------------------------------------------------------------------------------------------

### Зад. 1 Повтаряне на символен низ

## Обикновена рекурсия 

repeatString :: String -> Int -> String
repeatString str 0 = ""                                -- базов случай
repeatString str n = str ++ (repeatString str (n - 1)) -- рекурсивен случай

# Важно!!!
Всяко рекурсивно извикване създава ново ниво (stack frame) в стека на програмата.
	1. Извикване - repeatString "echo " 3   -- приема "echo echo" от извикване 2, конкатенира го с "echo" и извежда "echo echo echo"  
	2. Извикване - repeatString "echo " 2   -- приема "echo" от извикване 3, слепва го с "echo" и предава "echo echo" към извикване 1
	3. Извикване - repeatString "echo " 1   -- приема "" от извикване 4, конкатенира го с "echo" и предава "echo" към извикване 2
	4. Извикване - repeatString "echo " 0   -- Достига дъното на рекурсията и стека се разгъва - връща "" към извикване 3

## Опашкова рекурсия

repeatStringTail :: (Eq t, Num t) => [a] -> [a] -> t -> [a]
repeatStringTail str result n =
    if n == 0
        then result					  --Използва акумулатор (result), в който се натрупва частичният резултат.
        else repeatStringTail str (result ++ str) (n - 1) -- result се подава към следващото рекурсивно извикване.

# Важно!!!
Новото рекурсивно извикване приема като параметър резултатът от предходното изпълнение на функцията. 
Това позволява на Haskell да изпълнява рекурсията ефективно, без да натрупва нови нива в стека.
В резултат програмата използва постоянно количество памет, дори при големи входни данни.
Пример:
	1. Извикване - repeatStringTail "ha" "" 3		-- Презаписва фрайма
	2. Извикване - repeatStringTail "ha" "ha" 2		-- Презаписва фрайма
	3. Извикване - repeatStringTail "ha" "haha" 1		-- Презаписва фрайма
	4. Извикване - repeatStringTail "ha" "hahaha" 0  -- Достига базовия случай и връща "hahaha"
-----------------------------------------------------------------------------------------------------------

### Зад. 2 Факториел n

## Обикновена рекурсия
	
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * (factorial(n-1))

## Опашкова рекурсия

factorialTail :: (Eq t, Num t) => t -> t
factorialTail n = go n 1
  where
    go 0 acc = acc
    go k acc = go (k - 1) (acc * k)
---------------------------------------------------------------------------------------------------------------

### Зад. 3 - Функция, която повдига 2 на степен n

## Спомагателна рекурсивна функция, която имитира цикличен оператор с брояч

pow2loop :: (Ord t1, Num t2, Num t1) => t1 -> t2 -> t1 -> t2
pow2loop n x i =
    if i < n
        then pow2loop n (x * 2) (i + 1)
        else x


pow2 :: (Ord t1, Num t2, Num t1) => t1 -> t2
pow2 n = pow2loop n 1 0

----------------------------------------------------------------------------------------------------------------

### Зад. 4 - Сумиране на числа от 1 до 10 (рекурсивен цикъл)

sumNumberLoop :: (Ord t, Num t) => t -> t -> t
sumNumberLoop sum index =
    if index > 10
        then sum
        else sumNumberLoop (sum+index) (index +1)

sumNumber = sumNumberLoop 0 1

-----------------------------------------------------------------------------------------------------------------
